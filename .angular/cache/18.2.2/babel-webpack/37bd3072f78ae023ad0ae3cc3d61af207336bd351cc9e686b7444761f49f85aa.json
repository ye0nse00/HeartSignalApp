{"ast":null,"code":"import _asyncToGenerator from \"D:/Heart/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, Build, readTask, forceUpdate, h, Host } from '@stencil/core/internal/client';\nimport { i as inheritAriaAttributes, j as hasLazyBuild, c as componentOnReady } from './helpers.js';\nimport { b as getIonMode, a as isPlatform } from './ionic-global.js';\nimport { i as isRTL } from './dir.js';\nimport { c as createColorClasses, h as hostContext } from './theme.js';\nconst contentCss = \":host{--background:var(--ion-background-color, #fff);--color:var(--ion-text-color, #000);--padding-top:0px;--padding-bottom:0px;--padding-start:0px;--padding-end:0px;--keyboard-offset:0px;--offset-top:0px;--offset-bottom:0px;--overflow:auto;display:block;position:relative;-ms-flex:1;flex:1;width:100%;height:100%;margin:0 !important;padding:0 !important;font-family:var(--ion-font-family, inherit);contain:size style}:host(.ion-color) .inner-scroll{background:var(--ion-color-base);color:var(--ion-color-contrast)}#background-content{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);position:absolute;background:var(--background)}.inner-scroll{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:calc(var(--padding-top) + var(--offset-top));padding-bottom:calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));position:absolute;color:var(--color);-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;-ms-touch-action:pan-x pan-y pinch-zoom;touch-action:pan-x pan-y pinch-zoom}.scroll-y,.scroll-x{-webkit-overflow-scrolling:touch;z-index:0;will-change:scroll-position}.scroll-y{overflow-y:var(--overflow);overscroll-behavior-y:contain}.scroll-x{overflow-x:var(--overflow);overscroll-behavior-x:contain}.overscroll::before,.overscroll::after{position:absolute;width:1px;height:1px;content:\\\"\\\"}.overscroll::before{bottom:-1px}.overscroll::after{top:-1px}:host(.content-sizing){display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-height:0;contain:none}:host(.content-sizing) .inner-scroll{position:relative;top:0;bottom:0;margin-top:calc(var(--offset-top) * -1);margin-bottom:calc(var(--offset-bottom) * -1)}.transition-effect{display:none;position:absolute;width:100%;height:100vh;opacity:0;pointer-events:none}:host(.content-ltr) .transition-effect{left:-100%;}:host(.content-rtl) .transition-effect{right:-100%;}.transition-cover{position:absolute;right:0;width:100%;height:100%;background:black;opacity:0.1}.transition-shadow{display:block;position:absolute;width:100%;height:100%;-webkit-box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03);box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03)}:host(.content-ltr) .transition-shadow{right:0;}:host(.content-rtl) .transition-shadow{left:0;-webkit-transform:scaleX(-1);transform:scaleX(-1)}::slotted([slot=fixed]){position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0)}\";\nconst IonContentStyle0 = contentCss;\nconst Content = /*@__PURE__*/proxyCustomElement(class Content extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionScrollStart = createEvent(this, \"ionScrollStart\", 7);\n    this.ionScroll = createEvent(this, \"ionScroll\", 7);\n    this.ionScrollEnd = createEvent(this, \"ionScrollEnd\", 7);\n    this.watchDog = null;\n    this.isScrolling = false;\n    this.lastScroll = 0;\n    this.queued = false;\n    this.cTop = -1;\n    this.cBottom = -1;\n    this.isMainContent = true;\n    this.resizeTimeout = null;\n    this.inheritedAttributes = {};\n    this.tabsElement = null;\n    // Detail is used in a hot loop in the scroll event, by allocating it here\n    // V8 will be able to inline any read/write to it since it's a monomorphic class.\n    // https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html\n    this.detail = {\n      scrollTop: 0,\n      scrollLeft: 0,\n      type: 'scroll',\n      event: undefined,\n      startX: 0,\n      startY: 0,\n      startTime: 0,\n      currentX: 0,\n      currentY: 0,\n      velocityX: 0,\n      velocityY: 0,\n      deltaX: 0,\n      deltaY: 0,\n      currentTime: 0,\n      data: undefined,\n      isScrolling: true\n    };\n    this.color = undefined;\n    this.fullscreen = false;\n    this.fixedSlotPlacement = 'after';\n    this.forceOverscroll = undefined;\n    this.scrollX = false;\n    this.scrollY = true;\n    this.scrollEvents = false;\n  }\n  componentWillLoad() {\n    this.inheritedAttributes = inheritAriaAttributes(this.el);\n  }\n  connectedCallback() {\n    this.isMainContent = this.el.closest('ion-menu, ion-popover, ion-modal') === null;\n    /**\n     * The fullscreen content offsets need to be\n     * computed after the tab bar has loaded. Since\n     * lazy evaluation means components are not hydrated\n     * at the same time, we need to wait for the ionTabBarLoaded\n     * event to fire. This does not impact dist-custom-elements\n     * because there is no hydration there.\n     */\n    if (hasLazyBuild(this.el)) {\n      /**\n       * We need to cache the reference to the tabs.\n       * If just the content is unmounted then we won't\n       * be able to query for the closest tabs on disconnectedCallback\n       * since the content has been removed from the DOM tree.\n       */\n      const closestTabs = this.tabsElement = this.el.closest('ion-tabs');\n      if (closestTabs !== null) {\n        /**\n         * When adding and removing the event listener\n         * we need to make sure we pass the same function reference\n         * otherwise the event listener will not be removed properly.\n         * We can't only pass `this.resize` because \"this\" in the function\n         * context becomes a reference to IonTabs instead of IonContent.\n         *\n         * Additionally, we listen for ionTabBarLoaded on the IonTabs\n         * instance rather than the IonTabBar instance. It's possible for\n         * a tab bar to be conditionally rendered/mounted. Since ionTabBarLoaded\n         * bubbles, we can catch any instances of child tab bars loading by listening\n         * on IonTabs.\n         */\n        this.tabsLoadCallback = () => this.resize();\n        closestTabs.addEventListener('ionTabBarLoaded', this.tabsLoadCallback);\n      }\n    }\n  }\n  disconnectedCallback() {\n    this.onScrollEnd();\n    if (hasLazyBuild(this.el)) {\n      /**\n       * The event listener and tabs caches need to\n       * be cleared otherwise this will create a memory\n       * leak where the IonTabs instance can never be\n       * garbage collected.\n       */\n      const {\n        tabsElement,\n        tabsLoadCallback\n      } = this;\n      if (tabsElement !== null && tabsLoadCallback !== undefined) {\n        tabsElement.removeEventListener('ionTabBarLoaded', tabsLoadCallback);\n      }\n      this.tabsElement = null;\n      this.tabsLoadCallback = undefined;\n    }\n  }\n  /**\n   * Rotating certain devices can update\n   * the safe area insets. As a result,\n   * the fullscreen feature on ion-content\n   * needs to be recalculated.\n   *\n   * We listen for \"resize\" because we\n   * do not care what the orientation of\n   * the device is. Other APIs\n   * such as ScreenOrientation or\n   * the deviceorientation event must have\n   * permission from the user first whereas\n   * the \"resize\" event does not.\n   *\n   * We also throttle the callback to minimize\n   * thrashing when quickly resizing a window.\n   */\n  onResize() {\n    if (this.resizeTimeout) {\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = null;\n    }\n    this.resizeTimeout = setTimeout(() => {\n      /**\n       * Resize should only happen\n       * if the content is visible.\n       * When the content is hidden\n       * then offsetParent will be null.\n       */\n      if (this.el.offsetParent === null) {\n        return;\n      }\n      this.resize();\n    }, 100);\n  }\n  shouldForceOverscroll() {\n    const {\n      forceOverscroll\n    } = this;\n    const mode = getIonMode(this);\n    return forceOverscroll === undefined ? mode === 'ios' && isPlatform('ios') : forceOverscroll;\n  }\n  resize() {\n    /**\n     * Only force update if the component is rendered in a browser context.\n     * Using `forceUpdate` in a server context with pre-rendering can lead to an infinite loop.\n     * The `hydrateDocument` function in `@stencil/core` will render the `ion-content`, but\n     * `forceUpdate` will trigger another render, locking up the server.\n     *\n     * TODO: Remove if STENCIL-834 determines Stencil will account for this.\n     */\n    if (Build.isBrowser) {\n      if (this.fullscreen) {\n        readTask(() => this.readDimensions());\n      } else if (this.cTop !== 0 || this.cBottom !== 0) {\n        this.cTop = this.cBottom = 0;\n        forceUpdate(this);\n      }\n    }\n  }\n  readDimensions() {\n    const page = getPageElement(this.el);\n    const top = Math.max(this.el.offsetTop, 0);\n    const bottom = Math.max(page.offsetHeight - top - this.el.offsetHeight, 0);\n    const dirty = top !== this.cTop || bottom !== this.cBottom;\n    if (dirty) {\n      this.cTop = top;\n      this.cBottom = bottom;\n      forceUpdate(this);\n    }\n  }\n  onScroll(ev) {\n    const timeStamp = Date.now();\n    const shouldStart = !this.isScrolling;\n    this.lastScroll = timeStamp;\n    if (shouldStart) {\n      this.onScrollStart();\n    }\n    if (!this.queued && this.scrollEvents) {\n      this.queued = true;\n      readTask(ts => {\n        this.queued = false;\n        this.detail.event = ev;\n        updateScrollDetail(this.detail, this.scrollEl, ts, shouldStart);\n        this.ionScroll.emit(this.detail);\n      });\n    }\n  }\n  /**\n   * Get the element where the actual scrolling takes place.\n   * This element can be used to subscribe to `scroll` events or manually modify\n   * `scrollTop`. However, it's recommended to use the API provided by `ion-content`:\n   *\n   * i.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events\n   * and `scrollToPoint()` to scroll the content into a certain point.\n   */\n  getScrollElement() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      /**\n       * If this gets called in certain early lifecycle hooks (ex: Vue onMounted),\n       * scrollEl won't be defined yet with the custom elements build, so wait for it to load in.\n       */\n      if (!_this.scrollEl) {\n        yield new Promise(resolve => componentOnReady(_this.el, resolve));\n      }\n      return Promise.resolve(_this.scrollEl);\n    })();\n  }\n  /**\n   * Returns the background content element.\n   * @internal\n   */\n  getBackgroundElement() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.backgroundContentEl) {\n        yield new Promise(resolve => componentOnReady(_this2.el, resolve));\n      }\n      return Promise.resolve(_this2.backgroundContentEl);\n    })();\n  }\n  /**\n   * Scroll to the top of the component.\n   *\n   * @param duration The amount of time to take scrolling to the top. Defaults to `0`.\n   */\n  scrollToTop(duration = 0) {\n    return this.scrollToPoint(undefined, 0, duration);\n  }\n  /**\n   * Scroll to the bottom of the component.\n   *\n   * @param duration The amount of time to take scrolling to the bottom. Defaults to `0`.\n   */\n  scrollToBottom(duration = 0) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const scrollEl = yield _this3.getScrollElement();\n      const y = scrollEl.scrollHeight - scrollEl.clientHeight;\n      return _this3.scrollToPoint(undefined, y, duration);\n    })();\n  }\n  /**\n   * Scroll by a specified X/Y distance in the component.\n   *\n   * @param x The amount to scroll by on the horizontal axis.\n   * @param y The amount to scroll by on the vertical axis.\n   * @param duration The amount of time to take scrolling by that amount.\n   */\n  scrollByPoint(x, y, duration) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const scrollEl = yield _this4.getScrollElement();\n      return _this4.scrollToPoint(x + scrollEl.scrollLeft, y + scrollEl.scrollTop, duration);\n    })();\n  }\n  /**\n   * Scroll to a specified X/Y location in the component.\n   *\n   * @param x The point to scroll to on the horizontal axis.\n   * @param y The point to scroll to on the vertical axis.\n   * @param duration The amount of time to take scrolling to that point. Defaults to `0`.\n   */\n  scrollToPoint(x, y, duration = 0) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const el = yield _this5.getScrollElement();\n      if (duration < 32) {\n        if (y != null) {\n          el.scrollTop = y;\n        }\n        if (x != null) {\n          el.scrollLeft = x;\n        }\n        return;\n      }\n      let resolve;\n      let startTime = 0;\n      const promise = new Promise(r => resolve = r);\n      const fromY = el.scrollTop;\n      const fromX = el.scrollLeft;\n      const deltaY = y != null ? y - fromY : 0;\n      const deltaX = x != null ? x - fromX : 0;\n      // scroll loop\n      const step = timeStamp => {\n        const linearTime = Math.min(1, (timeStamp - startTime) / duration) - 1;\n        const easedT = Math.pow(linearTime, 3) + 1;\n        if (deltaY !== 0) {\n          el.scrollTop = Math.floor(easedT * deltaY + fromY);\n        }\n        if (deltaX !== 0) {\n          el.scrollLeft = Math.floor(easedT * deltaX + fromX);\n        }\n        if (easedT < 1) {\n          // do not use DomController here\n          // must use nativeRaf in order to fire in the next frame\n          requestAnimationFrame(step);\n        } else {\n          resolve();\n        }\n      };\n      // chill out for a frame first\n      requestAnimationFrame(ts => {\n        startTime = ts;\n        step(ts);\n      });\n      return promise;\n    })();\n  }\n  onScrollStart() {\n    this.isScrolling = true;\n    this.ionScrollStart.emit({\n      isScrolling: true\n    });\n    if (this.watchDog) {\n      clearInterval(this.watchDog);\n    }\n    // watchdog\n    this.watchDog = setInterval(() => {\n      if (this.lastScroll < Date.now() - 120) {\n        this.onScrollEnd();\n      }\n    }, 100);\n  }\n  onScrollEnd() {\n    if (this.watchDog) clearInterval(this.watchDog);\n    this.watchDog = null;\n    if (this.isScrolling) {\n      this.isScrolling = false;\n      this.ionScrollEnd.emit({\n        isScrolling: false\n      });\n    }\n  }\n  render() {\n    const {\n      fixedSlotPlacement,\n      inheritedAttributes,\n      isMainContent,\n      scrollX,\n      scrollY,\n      el\n    } = this;\n    const rtl = isRTL(el) ? 'rtl' : 'ltr';\n    const mode = getIonMode(this);\n    const forceOverscroll = this.shouldForceOverscroll();\n    const transitionShadow = mode === 'ios';\n    this.resize();\n    return h(Host, Object.assign({\n      key: '92a7cbc2e9c812930f4231bd846411933a5dded6',\n      role: isMainContent ? 'main' : undefined,\n      class: createColorClasses(this.color, {\n        [mode]: true,\n        'content-sizing': hostContext('ion-popover', this.el),\n        overscroll: forceOverscroll,\n        [`content-${rtl}`]: true\n      }),\n      style: {\n        '--offset-top': `${this.cTop}px`,\n        '--offset-bottom': `${this.cBottom}px`\n      }\n    }, inheritedAttributes), h(\"div\", {\n      key: '52498d8874b9944b8245e448ea9dfc75b3929c2d',\n      ref: el => this.backgroundContentEl = el,\n      id: \"background-content\",\n      part: \"background\"\n    }), fixedSlotPlacement === 'before' ? h(\"slot\", {\n      name: \"fixed\"\n    }) : null, h(\"div\", {\n      key: '00e157a53485b285300404178436276afceb63f5',\n      class: {\n        'inner-scroll': true,\n        'scroll-x': scrollX,\n        'scroll-y': scrollY,\n        overscroll: (scrollX || scrollY) && forceOverscroll\n      },\n      ref: scrollEl => this.scrollEl = scrollEl,\n      onScroll: this.scrollEvents ? ev => this.onScroll(ev) : undefined,\n      part: \"scroll\"\n    }, h(\"slot\", {\n      key: '8522320514a2e8a63f7dc9ade6c1fb3fb00f454e'\n    })), transitionShadow ? h(\"div\", {\n      class: \"transition-effect\"\n    }, h(\"div\", {\n      class: \"transition-cover\"\n    }), h(\"div\", {\n      class: \"transition-shadow\"\n    })) : null, fixedSlotPlacement === 'after' ? h(\"slot\", {\n      name: \"fixed\"\n    }) : null);\n  }\n  get el() {\n    return this;\n  }\n  static get style() {\n    return IonContentStyle0;\n  }\n}, [1, \"ion-content\", {\n  \"color\": [513],\n  \"fullscreen\": [4],\n  \"fixedSlotPlacement\": [1, \"fixed-slot-placement\"],\n  \"forceOverscroll\": [1028, \"force-overscroll\"],\n  \"scrollX\": [4, \"scroll-x\"],\n  \"scrollY\": [4, \"scroll-y\"],\n  \"scrollEvents\": [4, \"scroll-events\"],\n  \"getScrollElement\": [64],\n  \"getBackgroundElement\": [64],\n  \"scrollToTop\": [64],\n  \"scrollToBottom\": [64],\n  \"scrollByPoint\": [64],\n  \"scrollToPoint\": [64]\n}, [[9, \"resize\", \"onResize\"]]]);\nconst getParentElement = el => {\n  var _a;\n  if (el.parentElement) {\n    // normal element with a parent element\n    return el.parentElement;\n  }\n  if ((_a = el.parentNode) === null || _a === void 0 ? void 0 : _a.host) {\n    // shadow dom's document fragment\n    return el.parentNode.host;\n  }\n  return null;\n};\nconst getPageElement = el => {\n  const tabs = el.closest('ion-tabs');\n  if (tabs) {\n    return tabs;\n  }\n  /**\n   * If we're in a popover, we need to use its wrapper so we can account for space\n   * between the popover and the edges of the screen. But if the popover contains\n   * its own page element, we should use that instead.\n   */\n  const page = el.closest('ion-app, ion-page, .ion-page, page-inner, .popover-content');\n  if (page) {\n    return page;\n  }\n  return getParentElement(el);\n};\n// ******** DOM READ ****************\nconst updateScrollDetail = (detail, el, timestamp, shouldStart) => {\n  const prevX = detail.currentX;\n  const prevY = detail.currentY;\n  const prevT = detail.currentTime;\n  const currentX = el.scrollLeft;\n  const currentY = el.scrollTop;\n  const timeDelta = timestamp - prevT;\n  if (shouldStart) {\n    // remember the start positions\n    detail.startTime = timestamp;\n    detail.startX = currentX;\n    detail.startY = currentY;\n    detail.velocityX = detail.velocityY = 0;\n  }\n  detail.currentTime = timestamp;\n  detail.currentX = detail.scrollLeft = currentX;\n  detail.currentY = detail.scrollTop = currentY;\n  detail.deltaX = currentX - detail.startX;\n  detail.deltaY = currentY - detail.startY;\n  if (timeDelta > 0 && timeDelta < 100) {\n    const velocityX = (currentX - prevX) / timeDelta;\n    const velocityY = (currentY - prevY) / timeDelta;\n    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;\n    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;\n  }\n};\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-content\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"ion-content\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, Content);\n        }\n        break;\n    }\n  });\n}\nconst IonContent = Content;\nconst defineCustomElement = defineCustomElement$1;\nexport { IonContent, defineCustomElement };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}