{"ast":null,"code":"import _asyncToGenerator from \"D:/Heart/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h } from '@stencil/core/internal/client';\nimport { g as getTimeGivenProgression } from './cubic-bezier.js';\nimport { a as attachComponent, d as detachComponent } from './framework-delegate.js';\nimport { s as shallowEqualStringMap, j as hasLazyBuild } from './helpers.js';\nimport { c as createLockController } from './lock-controller.js';\nimport { t as transition } from './index2.js';\nimport { b as getIonMode, c as config } from './ionic-global.js';\nconst routerOutletCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;z-index:0}\";\nconst IonRouterOutletStyle0 = routerOutletCss;\nconst RouterOutlet = /*@__PURE__*/proxyCustomElement(class RouterOutlet extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionNavWillLoad = createEvent(this, \"ionNavWillLoad\", 7);\n    this.ionNavWillChange = createEvent(this, \"ionNavWillChange\", 3);\n    this.ionNavDidChange = createEvent(this, \"ionNavDidChange\", 3);\n    this.lockController = createLockController();\n    this.gestureOrAnimationInProgress = false;\n    this.mode = getIonMode(this);\n    this.delegate = undefined;\n    this.animated = true;\n    this.animation = undefined;\n    this.swipeHandler = undefined;\n  }\n  swipeHandlerChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeHandler !== undefined);\n    }\n  }\n  connectedCallback() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const onStart = () => {\n        _this.gestureOrAnimationInProgress = true;\n        if (_this.swipeHandler) {\n          _this.swipeHandler.onStart();\n        }\n      };\n      _this.gesture = (yield import('./swipe-back.js')).createSwipeBackGesture(_this.el, () => !_this.gestureOrAnimationInProgress && !!_this.swipeHandler && _this.swipeHandler.canStart(), () => onStart(), step => {\n        var _a;\n        return (_a = _this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step);\n      }, (shouldComplete, step, dur) => {\n        if (_this.ani) {\n          _this.ani.onFinish(() => {\n            _this.gestureOrAnimationInProgress = false;\n            if (_this.swipeHandler) {\n              _this.swipeHandler.onEnd(shouldComplete);\n            }\n          }, {\n            oneTimeCallback: true\n          });\n          // Account for rounding errors in JS\n          let newStepValue = shouldComplete ? -0.001 : 0.001;\n          /**\n           * Animation will be reversed here, so need to\n           * reverse the easing curve as well\n           *\n           * Additionally, we need to account for the time relative\n           * to the new easing curve, as `stepValue` is going to be given\n           * in terms of a linear curve.\n           */\n          if (!shouldComplete) {\n            _this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n            newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n          } else {\n            newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n          }\n          _this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n        } else {\n          _this.gestureOrAnimationInProgress = false;\n        }\n      });\n      _this.swipeHandlerChanged();\n    })();\n  }\n  componentWillLoad() {\n    this.ionNavWillLoad.emit();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /** @internal */\n  commit(enteringEl, leavingEl, opts) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const unlock = yield _this2.lockController.lock();\n      let changed = false;\n      try {\n        changed = yield _this2.transition(enteringEl, leavingEl, opts);\n      } catch (e) {\n        console.error(e);\n      }\n      unlock();\n      return changed;\n    })();\n  }\n  /** @internal */\n  setRouteId(id, params, direction, animation) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const changed = yield _this3.setRoot(id, params, {\n        duration: direction === 'root' ? 0 : undefined,\n        direction: direction === 'back' ? 'back' : 'forward',\n        animationBuilder: animation\n      });\n      return {\n        changed,\n        element: _this3.activeEl\n      };\n    })();\n  }\n  /** @internal */\n  getRouteId() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const active = _this4.activeEl;\n      return active ? {\n        id: active.tagName,\n        element: active,\n        params: _this4.activeParams\n      } : undefined;\n    })();\n  }\n  setRoot(component, params, opts) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (_this5.activeComponent === component && shallowEqualStringMap(params, _this5.activeParams)) {\n        return false;\n      }\n      // attach entering view to DOM\n      const leavingEl = _this5.activeEl;\n      const enteringEl = yield attachComponent(_this5.delegate, _this5.el, component, ['ion-page', 'ion-page-invisible'], params);\n      _this5.activeComponent = component;\n      _this5.activeEl = enteringEl;\n      _this5.activeParams = params;\n      // commit animation\n      yield _this5.commit(enteringEl, leavingEl, opts);\n      yield detachComponent(_this5.delegate, leavingEl);\n      return true;\n    })();\n  }\n  transition(enteringEl, leavingEl, opts = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (leavingEl === enteringEl) {\n        return false;\n      }\n      // emit nav will change event\n      _this6.ionNavWillChange.emit();\n      const {\n        el,\n        mode\n      } = _this6;\n      const animated = _this6.animated && config.getBoolean('animated', true);\n      const animationBuilder = opts.animationBuilder || _this6.animation || config.get('navAnimation');\n      yield transition(Object.assign(Object.assign({\n        mode,\n        animated,\n        enteringEl,\n        leavingEl,\n        baseEl: el,\n        /**\n         * We need to wait for all Stencil components\n         * to be ready only when using the lazy\n         * loaded bundle.\n         */\n        deepWait: hasLazyBuild(el),\n        progressCallback: opts.progressAnimation ? ani => {\n          /**\n           * Because this progress callback is called asynchronously\n           * it is possible for the gesture to start and end before\n           * the animation is ever set. In that scenario, we should\n           * immediately call progressEnd so that the transition promise\n           * resolves and the gesture does not get locked up.\n           */\n          if (ani !== undefined && !_this6.gestureOrAnimationInProgress) {\n            _this6.gestureOrAnimationInProgress = true;\n            ani.onFinish(() => {\n              _this6.gestureOrAnimationInProgress = false;\n              if (_this6.swipeHandler) {\n                _this6.swipeHandler.onEnd(false);\n              }\n            }, {\n              oneTimeCallback: true\n            });\n            /**\n             * Playing animation to beginning\n             * with a duration of 0 prevents\n             * any flickering when the animation\n             * is later cleaned up.\n             */\n            ani.progressEnd(0, 0, 0);\n          } else {\n            _this6.ani = ani;\n          }\n        } : undefined\n      }, opts), {\n        animationBuilder\n      }));\n      // emit nav changed event\n      _this6.ionNavDidChange.emit();\n      return true;\n    })();\n  }\n  render() {\n    return h(\"slot\", {\n      key: '8279a453c66a766e6e383ff59842b4ae070c13a9'\n    });\n  }\n  get el() {\n    return this;\n  }\n  static get watchers() {\n    return {\n      \"swipeHandler\": [\"swipeHandlerChanged\"]\n    };\n  }\n  static get style() {\n    return IonRouterOutletStyle0;\n  }\n}, [1, \"ion-router-outlet\", {\n  \"mode\": [1025],\n  \"delegate\": [16],\n  \"animated\": [4],\n  \"animation\": [16],\n  \"swipeHandler\": [16],\n  \"commit\": [64],\n  \"setRouteId\": [64],\n  \"getRouteId\": [64]\n}, undefined, {\n  \"swipeHandler\": [\"swipeHandlerChanged\"]\n}]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-router-outlet\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"ion-router-outlet\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, RouterOutlet);\n        }\n        break;\n    }\n  });\n}\nconst IonRouterOutlet = RouterOutlet;\nconst defineCustomElement = defineCustomElement$1;\nexport { IonRouterOutlet, defineCustomElement };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}